<!DOCTYPE html>
<html>
  <head>
    <script>
      var host = ".github.io";
      if (/\.github.io/.test(window.location.host) && window.location.protocol != "https:")
        window.location.protocol = "https";
    </script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, target-densityDpi=medium-dpi">
    <meta content="True" name="HandheldFriendly">
    <title>ES7 async functions - a step in the wrong direction</title>
    <link rel="shortcut icon" href="/ico/favicon.ico">
    <link rel="stylesheet" href="/styles/style.css">
    <link rel="stylesheet" href="//google-code-prettify.googlecode.com/svn/trunk/src/prettify.css">
    <link rel="alternate" type="application/rss+xml" title="spion.github.io" href="/rss.xml">
  </head>
  <body>
    <div class="main">
      <div class="info-tiny"><a href="/" class="img"><img src="https://secure.gravatar.com/avatar/d924ad2ac22af6216aadd2e9184616de?s=144"></a>
        <h1 class="first"><a href="/">Gorgi Kosev</a></h1>
        <p class="subtitle">code, music, math</p>
      </div>
      <div class="info"><a href="/" class="img"><img src="https://secure.gravatar.com/avatar/d924ad2ac22af6216aadd2e9184616de?s=144"></a>
        <h1 class="first"><a href="/">Gorgi Kosev</a></h1>
        <p class="subtitle">code, music, math</p>
        <p class="subtitle margin"><a href="http://twitter.com/spion">@spion</a></p>
      </div>
      <div class="rest">
<div class="post">
  <h1>ES7 async functions - a step in the wrong direction</h1>
  <div class="date">Sat Aug 22 2015</div>
  <div class="content"><p>Async functions are a new feature scheduled to become a part of ES7. They build
on top of previous capabilities made available by ES6 (promises), letting you
write async code as though it were synchronous. At the moment, they&#39;re a
<a href="https://github.com/lukehoban/ecmascript-asyncawait">stage 1 proposal for ES7</a> and supported by babel /
regenerator.</p>
<p>When generator functions were first made available in node, I was
<a href="https://spion.github.io/posts/analysis-generators-and-other-async-patterns-node.html">very excited</a>. Finally, a way to write asynchronous JavaScript that
doesn&#39;t descend into callback hell! At the time, I was unfamiliar with promises
and the language power you get back by simply having async computations be
first class values, so it seemed to me that generators are the best solution
available.</p>
<p>Turns out, they aren&#39;t. And the same limitations apply for async functions.</p>
<h3 id="predicates-in-catch-statements">Predicates in catch statements</h3>
<p>With generators, thrown errors bubble up the function chain until a catch
statement is encountered, much like in other languages that support exceptions.
On one hand, this is convenient, but on the other, you never know what you&#39;re
catching once you write a catch statement.</p>
<p>JavaScript catch doesn&#39;t support any mechanism to filter errors. This
limitation isn&#39;t too hard to get around: we can write a function <code>guard</code></p>
<pre><code class="lang-js">function guard(e, predicate) {
  if (!predicate(e)) throw e;
}
</code></pre>
<p>and then use it to e.g. only filter &quot;not found&quot; errors when downloading an
image</p>
<pre><code class="lang-js">try {
    await downloadImage(url);
} catch (e) { guard(e, e =&gt; e.code == 404);
    handle404(...);
}
</code></pre>
<p>But that only gets us so far. What if we want to have a second error handler?
We must resort to using <code>if-then-else</code>, making sure that we don&#39;t forget to
rethrow the error at the end</p>
<pre><code class="lang-js">try {
    await downloadImage(url);
} catch (e) {
    if (e.code == 404)  {
        handle404(...)
    } else if (e.code == 401) {
        handle401(...);
    } else {
        throw e;
    }
}
</code></pre>
<p>Since promises are a userland library, restrictions like the above do not
apply. We can write our own promise implementation that demands the use of a
predicate filter:</p>
<pre><code class="lang-js">downloadImage(url)
.catch(e =&gt; e.code == 404, e =&gt; {
    handle404(...);
})
.catch(e =&gt; e.code == 401, e =&gt; {
    handle401(...)
})
</code></pre>
<p>Now if we want all errors to be caught, we have to say it explicitly:</p>
<pre><code class="lang-js">asyncOperation()
.catch(e =&gt; true, e =&gt; {
    handleAllErrors(...)
});
</code></pre>
<p>Since these constructs are not built-in language features but a DSL built on
top of higher order functions, we can impose any restrictions we like instead
of waiting on TC39 to fix the language.</p>
<h3 id="cannot-use-higher-order-functions">Cannot use higher order functions</h3>
<p>Because generators and async-await are shallow, you cannot use <code>yield</code> or
<code>await</code> within lambdas passed to higher order functions.</p>
<p>This is <a href="https://github.com/tc39/ecmascript-asyncawait/issues/7">better explained here</a> - The example given
there is</p>
<pre><code class="lang-js">async function renderChapters(urls) {
  urls.map(getJSON).forEach(j =&gt; addToPage((await j).html));
}
</code></pre>
<p>and will not work, because you&#39;re not allowed to use await from within a nested
function. The following will work, but will execute in parallel:</p>
<pre><code class="lang-js">async function renderChapters(urls) {
  urls.map(getJSON).forEach(async j =&gt; addToPage((await j).html));
}
</code></pre>
<p>To understand why, you need to read <a href="http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/">this article</a>. In short:
its much harder to implement deep coroutines so browser vendors probably wont
do it.</p>
<p>Besides being very unintuitive, this is also limiting. Higher order functions
are succint and powerful, yet we cannot <em>really</em> use them inside async
functions. To get sequential execution we have to resort to the clumsy built
in for loops which often force us into writing ceremonial, stateful code.</p>
<h3 id="arrow-functions-give-us-more-power-than-ever-before">Arrow functions give us more power than ever before</h3>
<p>Functional DSLs were very powerful even before JS had short lambda syntax. But
with arrow functions, things get even cleaner. The amount of code one needs to
write can be reduced greatly thanks to short lambda syntax and higher order
functions. Lets take the motivating example from the async-await proposal</p>
<pre><code class="lang-js">function chainAnimationsPromise(elem, animations) {
    var ret = null;
    var p = currentPromise;
    for(var anim of animations) {
        p = p.then(function(val) {
            ret = val;
            return anim(elem);
        })
    }
    return p.catch(function(e) {
        /* ignore and keep going */
    }).then(function() {
        return ret;
    });
}
</code></pre>
<p>With bluebird&#39;s <code>Promise.reduce</code>, this becomes</p>
<pre><code class="lang-js">function chainAnimationsPromise(elem, animations) {
  return Promise.reduce(animations,
      (lastVal, anim) =&gt; anim(elem).catch(_ =&gt; Promise.reject(lastVal)),
      Promise.resolve(null))
  .catch(lastVal =&gt; lastVal);
}
</code></pre>
<p>In short: functional DSLs are now more powerful than built in constructs,
even though (admittedly) they may take some getting used to.</p>
<hr>
<p>But this is not why async functions are a step in the wrong direction. The
problems above are not unique to async functions. The same problems apply to
generators: async functions merely inherit them as they&#39;re very similar.</p>
<p>Async functions also go another step backwards.</p>
<h2 id="loss-of-generality-and-power">Loss of generality and power</h2>
<p>Despite their shortcomings, generator based coroutines have one redeeming
quality: they allow you to redefine the coroutine execution engine. This is
extremely powerful, and I will demonstrate by giving the following example:</p>
<p>Lets say we were given the task to write the save function for an issue
tracker. The issue author can specify the issue&#39;s title and text, as well
as any other issues that are blocking the solution of the newly entered issue.</p>
<p>Our initial implementation is simple:</p>
<pre><code class="lang-js">async function saveIssue(data, blockers) {
    let issue = await Issues.insert(data);
    for (let blockerId of blockers) {
      await BlockerIssues.insert({blocker: blockerId, blocks: issue.id});
    }
}

Issues.insert = async function(data) {
    return db.query(&quot;INSERT ... VALUES&quot;, data).execWithin(db.pool);
}

BlockerIssue.insert = async function(data) {
    return db.query(&quot;INSERT .... VALUES&quot;, data).execWithin(db.pool);
}
</code></pre>
<p><code>Issue</code> and <code>BlockerIssues</code> are references to the corresponding tables in an
SQL database. Their <code>insert</code> methods return a promise that indicate whether
the query has been completed. The query is executed by a connection pool.</p>
<p>But then, we run into a problem. We don&#39;t want to partially save the issue if
some of the data was not inserted successfuly. We want the entire save
operation to be atomic. Fortunately, SQL databases support this via
transactions, and our database library has a transaction abstraction. So we
change our code:</p>
<pre><code class="lang-js">async function saveIssue(data, blockers) {
    let tx = db.beginTransaction();
    let issue = await Issue.insert(tx, data);
    for (let blockerId of blockers) {
      await BlockerIssues.insert(tx, {blocker: blockerId, blocks: issue.id});
    }
}

Issues.insert = async function(tx, data) {
    return db.query(&quot;INSERT ... VALUES&quot;, data).execWithin(tx);
}

BlockerIssue.insert = async function(tx, data) {
    return db.query(&quot;INSERT .... VALUES&quot;, data).execWithin(tx);
}
</code></pre>
<p>Here, we changed the code in two ways. Firstly, we created a transaction within
the saveIssue function. Secondly, we changed both insert methods to take this
transaction as an argument.</p>
<p>Immediately we can see that this solution doesn&#39;t scale very well. What if
we need to use <code>saveIssue</code> as a part of a larger transaction? Then it has to
take a transaction as an argument. Who will create the transactions? The top
level service. What if the top level service becomes a part of a larger
service? Then we need to change the code again.</p>
<p>We can reduce the extent of this problem by writing a base class that
automatically initializes a transaction if one is not passed via the
constructor, and then have <code>Issues</code>, <code>BlockerIssue</code> etc inherit from this
class.</p>
<pre><code>
class Transactionable {
    constructor(tx) {
        this.transaction = tx || db.beginTransaction();
    }
}
class IssueService extends Transactionable {
    async saveIssue(data, blockers) {
        issues = new Issues(this.transaction);
        blockerIssues = new BlockerIssues(this.transaction);
        ...
    }
}
class Issues extends Transactionable {
  ...
}
// etc
</code></pre><p>Like many OO solutions, this only spreads the problem across the plate to make
it look smaller but doesn&#39;t solve it.</p>
<h2 id="generators-are-better">Generators are better</h2>
<p>Generators let us define the execution engine. The iteration is driven by the
function that consumes the generator, which decides what to do with the yielded
values. What if instead of only allowing promises, our engine let us also:</p>
<ol>
<li>Specify additional options which are accessible from within</li>
<li>Yield queries. These will be run in the transaction specified in the options
above</li>
<li>Yield other generator iterables: These will be run with the same engine and
options</li>
<li>Yield promises: These will be handled normally</li>
</ol>
<p>Lets take the original code and simplify it:</p>
<pre><code class="lang-js">
function* saveIssue(data, blockers) {
    let issue = yield Issues.insert(data);
    for (var blockerId of blockers) {
      yield BlockerIssues.insert({blocker: blockerId, blocks: issue.id});
    }
}

Issues.insert = function* (data) {
    return db.query(&quot;INSERT ... VALUES&quot;, data)
}

BlockerIssue.insert = function* (data) {
    return db.query(&quot;INSERT .... VALUES&quot;, data)
}
</code></pre>
<p>From our http handler, we can now write</p>
<pre><code class="lang-js">var myengine = require(&#39;./my-engine&#39;);

app.post(&#39;/issues/save&#39;, function(req, res) {
  myengine.run(saveIssue(data, blockers), {tx: db.beginTransaction()})
});
</code></pre>
<p>Lets implement this engine:</p>
<pre><code class="lang-js">function run(iterator, options) {
    function id(x) { return x; }
    function iterate(value) {
        var next = iterator.next(value)
        var request = next.value;
        var nextAction = next.done ? id : iterate;

        if (isIterator(request)) {
            return run(request, options).then(nextAction)
        }
        else if (isQuery(request)) {
            return request.execWithin(options.tx).then(nextAction)
        }
        else if (isPromise(request)) {
            return request.then(nextAction);
        }
    }
    return iterate()
}
</code></pre>
<p>The best part of this change is that we did not have to change the original
code at all. We didn&#39;t have to add the transaction parameter to every function,
to take care to properly propagate it everywhere and to properly create the
transaction. All we needed to do is just change our execution engine.</p>
<p>And we can add much more! We can <code>yield</code> a request to get the current user
if any, so we don&#39;t have to thread that through our code. Infact we can
implement <a href="https://github.com/othiym23/node-continuation-local-storage">continuation local storage</a> with only a few lines of code.</p>
<p>Async generators are often given as a reason why we need async functions. If
yield is already being used as await, how can we get both working at the same
time without adding a new keyword? Is that even possible?</p>
<p>Yes. Here is a simple proof-of-concept.
<a href="https://github.com/spion/async-generators">github.com/spion/async-generators</a>.
All we needed to do is change the execution engine to support a mechanism
to distinguish between awaited and yielded values.</p>
<p>Another example worth exploring is a query optimizer that supports aggregate
execution of queries. If we replace <code>Promise.all</code> with our own implementaiton
caled <code>parallel</code>, then we can add support for non-promise arguments.</p>
<p>Lets say we have the following code to notify owners of blocked issues in
parallel when an issue is resolved:</p>
<pre><code class="lang-js">let blocked = yield BlockerIssues.where({blocker: blockerId})
let owners  = yield engine.parallel(blocked.map(issue =&gt; issue.getOwner()))

for (let owner of owners) yield owner.notifyResolved(issue)
</code></pre>
<p>Instead of returning an SQL based query, we can have <code>getOwner()</code> return data
about the query:</p>
<pre><code class="lang-js">{table: &#39;users&#39;, id: issue.user_id}
</code></pre>
<p>and have <code>engine</code> optimize the execution of parallel queries, by sending
a single query per table rather then per item.</p>
<pre><code class="lang-js">if (isParallelQuery(query)) {
    var results = _(query.items).groupBy(&#39;table&#39;)
      .map((items, t) =&gt; db.query(`select * from ${t} where id in ?`,
                                  items.map(it =&gt; it.id))
                .execWithin(options.tx)).toArray();
    Promise.all(results)
        .then(results =&gt; results.sort(byOrderOf(query.items)))
        .then(runNext)
}
</code></pre>
<p>And voila, we&#39;ve just implemented a query optimizer. It will fetch all issue
owners with a single query. If we add an SQL parser into the mix, it should
be possible to rewrite real SQL queries.</p>
<p>We can do something similar on the client too with GraphQL queries by aggregating
multiple individual queries.</p>
<p>And if we add support for iterators, the optimization becomes deep:
we would be able to aggregate queries that are several layers within other
generator functions,  In the above example, <code>getOwner()</code> could be another
generatator which produces a query for the user as a first result. Our
implementation of <code>parallel</code> will run all those getOwner() iterators and
consolidate their first queries into a single query. All this is done without
those functions knowing anything about it (thus, without breaking modularity).</p>
<p>Async functions cant let us do any of this. All we get is a single execution
engine that only knows how to await promises. To make matters worse, thanks
to the unfortunately short-sighted <a href="https://esdiscuss.org/topic/a-challenge-problem-for-promise-designers-was-re-futures">recursive thenable assimilation</a>
design decision, we can&#39;t simply create our own thenable that will support
the above extra features. If we try to do that, we will be
<a href="https://github.com/Reactive-Extensions/RxJS/issues/470">unable to safely use it with Promises</a>.
We&#39;re stuck with what we get by default in async functions, and
thats it.</p>
<p>Generators are JavaScript&#39;s programmable semicolons. Lets not take away that
power by taking away the programmability. Lets drop async/await and write our
own interpreters.</p>
</div><a name="_comments"></a>
  <div class="social">
    <script src="https://apis.google.com/js/plusone.js"></script><a href="https://twitter.com/share" data-via="spion" class="twitter-share-button">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <div class="g-plusone"></div><a href="http://news.ycombinator.com/submit" class="hn-share-button">Vote on HN            </a>
    <script>
      (function(d, t) {
          var g = d.createElement(t),
              s = d.getElementsByTagName(t)[0];
          g.src = '//hnbutton.appspot.com/static/hn.min.js';
          s.parentNode.insertBefore(g, s);
      }(document, 'script'));    
    </script>
  </div>
  <div id="disqus_thread"></div>
  <script>
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ahintofchaos'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <!--
  a.dsq-brink(href="http://disqus.com") comments powered by 
    span.logo-disqus Disqus
  -->
</div></div>
    </div>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/katex.min.css">
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
    <script src="//google-code-prettify.googlecode.com/svn/trunk/src/prettify.js"></script>
    <script>
      $('code').addClass('prettyprint');
      prettyPrint();
    </script>
    <script src="/scripts/jquery.flot.js"></script>
    <script src="/scripts/jquery.flot.highlightSeries.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-42872676-1', 'spion.github.io');
      ga('send', 'pageview');
    </script>
  </body>
</html>